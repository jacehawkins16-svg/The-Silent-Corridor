<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Silent Corridor: Expanded Edition</title>
    <style>

/* Global Styles & Atmosphere */
body {
    /* 1. AMBIENT BACKGROUND: Dark Red/Black (The background 'revealed' by the flashlight) */
    background-color: #110000; 
    color: #aaa; 
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    justify-content: center;
    align-items: center; 
    height: 100vh;
    width: 100vw; 
    margin: 0;
    padding: 0; 
    overflow: hidden; 
    
    position: relative;
    z-index: 0; /* Ensures content is above the base body background */
    
    /* Flashlight Variables */
    --x: 50vw; /* Mouse X position, updated by JS */
    --y: 50vh; /* Mouse Y position, updated by JS */
    --flashlight-size: 300px; 

    /* Set a fixed dark background, NOT a gradient, to serve as the ambient color */
    background: #110000; 
    background-attachment: fixed;
    transition: none !important; 
}

/* 2. body::before provides the WHITE/RED light color over the ambient background */
body::before {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 10; /* Below the content/shadow layers */
    pointer-events: none; 
    
    /* THE LIGHT COLOR: Soft white center with red edge fading to transparent (reveals ambient body background) */
    background: radial-gradient(
        circle var(--flashlight-size) at var(--x) var(--y), 
        rgba(255, 255, 255, 0.15) 0%,     /* Bright center */
        rgba(255, 85, 85, 0.05) 50%,    /* Red glow */
        transparent 100% 
    );
    background-blend-mode: overlay; /* Blending mode for a soft light effect */
}

/* 3. body::after is the BLACK SHADOW MASK with a transparent hole */
body::after {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 12; /* Sits on top of the content and light source */
    pointer-events: none;

    background-color: #000; /* The shadow color */
    opacity: 0.95; /* Control the overall darkness level */
    
    /* THE MASK: Creates a transparent hole in the shadow layer */
    mask-image: radial-gradient(
        circle var(--flashlight-size) at var(--x) var(--y),
        transparent 0%, 
        transparent 70%,
        black 100% 
    );
    -webkit-mask-image: radial-gradient(
        circle var(--flashlight-size) at var(--x) var(--y),
        transparent 0%,
        transparent 70%,
        black 100%
    );
}


.container {
    max-width: 700px;
    width: 95%; 
    box-sizing: border-box;
    
    max-height: 100vh; 
    overflow-y: auto;
    overflow-x: hidden; 
    
    text-align: left;
    line-height: 1.6;
    animation: none !important; 
    /* Restored a defined background color for the content box to sit on the ambient light */
    background-color: rgba(17, 0, 0, 0.7); 
    padding: 20px; 
    border-radius: 5px;
    /* Removed box shadow as it would be visible outside the light */
    box-shadow: none; 
    position: relative; 
    transition: margin-left 0.5s; 
    z-index: 11; /* Sits above the light source and below the shadow mask */
}
        h1 {
            color: #f55; 
            text-align: center;
            border-bottom: 1px solid #f55; 
            padding-bottom: 10px;
            text-transform: uppercase;
        }

        /* --- Glitch Effect CSS (Randomized screen shake) --- */
        .glitch-active {
            animation: shake 0.1s infinite alternate;
            filter: invert(10%) grayscale(80%) hue-rotate(330deg); 
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            100% { transform: translate(-1px, -1px) rotate(0.1deg); }
        }

        /* --- Screen Management --- */
        .screen {
            display: none;
            width: 100%;
            opacity: 1;
            transition: opacity 2.0s ease-in-out; 
        }
        .screen.active {
            display: block;
        }
        
        .fade-out {
            opacity: 0;
        }

/* --- Start Menu & Animation Styles --- */
#start-screen {
    text-align: center;
    padding: 40px 20px; 
}

        #start-title {
            font-size: 2.5em;
            margin-bottom: 40px;
            border-bottom: none; 
            padding-bottom: 0;
            animation-name: titleMove; 
            animation-duration: 4s;
            animation-timing-function: ease-in-out;
            animation-iteration-count: infinite;
            animation-direction: alternate;
        }
        @keyframes titleMove {
            0% { transform: translateX(-10px) rotate(-1.5deg); }
            50% { transform: translateX(10px) rotate(1.5deg); }
            100% { transform: translateX(-10px) rotate(-1.5deg); }
        }

        #start-button, #endings-button {
            max-width: 300px;
            margin: 10px auto; 
            font-size: 1.2em;
            padding: 15px 30px;
            border-color: #f55; 
            width: auto !important; 
        }

        /* --- Game Screen Elements --- */
        
        #story-text {
            margin-top: 20px;
            font-size: 1em;
            min-height: 200px; 
        }
        
        #story-text h2 { 
            text-align: center;
            font-size: 1.5em;
            color: #f55; 
            margin-top: 20px;
            border-bottom: none;
            text-transform: none;
        }
        
        #story-text p.description {
            margin-bottom: 30px;
            font-style: italic;
        }
        
        /* Interaction Buttons */
        .choice-btn {
            background-color: transparent;
            border: 1px solid #f55; 
            color: #f55; 
            padding: 10px 15px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            transition: color 0.3s, background-color 0.3s, border-color 0.3s;
            width: 100%;
            box-sizing: border-box;
            display: block;
        }
        .choice-btn:hover {
            color: #fff; 
            border-color: #fff; 
            background-color: #220000; 
        }
        
        /* Game Over State */
        .game-over h1, .game-over .choice-btn {
            color: #ff0000; 
            border-color: #ff0000; 
        }
        .game-over .choice-btn:hover {
            background-color: #330000; 
        }
        
/* --- ENDINGS MENU SIDEBAR --- */
#endings-sidebar {
    height: 90vh; 
    width: 300px; 
    position: fixed;
    z-index: 20; /* Highest Z-index */
    top: 50%; 
    right: 0;
    background-color: rgba(17, 0, 0, 0.9); /* Dark, slightly red sidebar */
    overflow-x: hidden;
    transition: 0.5s;
    padding-top: 20px; 
    /* PUSH OFF-SCREEN and VERTICALLY CENTER */
    transform: translateY(-50%) translateX(100%); 
    box-shadow: -5px 0 15px rgba(255, 85, 85, 0.2); 
    border-left: 1px solid #f55; 
    display: flex;
    flex-direction: column;
}

#endings-sidebar.open {
    /* PULL BACK ON-SCREEN while maintaining vertical center */
    transform: translateY(-50%) translateX(0); 
}

#endings-list-content {
    padding: 0 15px 15px 15px;
    overflow-y: auto;
    flex-grow: 1; 
}

        #endings-sidebar h3 {
            color: #f55; 
            text-align: center;
            margin-top: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f55; 
            text-transform: uppercase;
            font-size: 1.2em;
        }

        .ending-item {
            padding: 8px 0;
            border-bottom: 1px dotted #444; 
            color: #666; 
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            line-height: 1.2;
        }

        .ending-item.unlocked {
            color: #aaa; 
            font-weight: bold;
        }

        .ending-item .status {
            color: #ff0000; 
            margin-left: 10px;
            min-width: 10px; 
        }
        
        .ending-item.unlocked .status {
            color: #44ff44; 
        }
        
        .ending-name {
            flex-grow: 1; 
        }
        
        .closebtn {
            position: absolute;
            top: 0;
            right: 25px;
            font-size: 36px;
            margin-left: 50px;
            cursor: pointer;
            color: #f55; 
            text-decoration: none;
            line-height: 60px;
        }

        /* Adjustment to push main content when sidebar is open */
        body.sidebar-open .container {
            margin-right: 300px; 
        }

@media (max-width: 768px) {
    .container {
        padding: 10px;
    }
    /* NEW: Use 90% width on smaller screens */
    #endings-sidebar {
        width: 90%;
    }
    /* Adjust content spacing for smaller screens */
    #story-text {
        min-height: 150px; 
    }
}

/* --- Custom Scrollbar Styling for Aesthetics --- */
/* Targetting the element with isolated scrolling */
#endings-list-content::-webkit-scrollbar {
    width: 8px;
    background-color: #111; 
}

#endings-list-content::-webkit-scrollbar-thumb {
    background-color: #f55; 
    border-radius: 4px;
    border: 1px solid #330000; 
}

#endings-list-content::-webkit-scrollbar-thumb:hover {
    background-color: #fff; 
}
    </style>
</head>
<body>
    
    <audio id="rainSfx" loop preload="auto" src="rain sfx.mp3"></audio>
    <audio id="ambianceSfx" loop preload="auto" src="ambiance sfx.mp3"></audio>

    <div id="endings-sidebar">
        <a href="javascript:void(0)" class="closebtn" onclick="toggleEndingsMenu()">&times;</a>
        <h3>Endings Tracker</h3>
        <div id="endings-list-content">
            </div>
    </div>
    
    <div class="container" id="gameContainer">
        
        <div id="start-screen" class="screen active">
            <h1 id="start-title">The Silent Corridor</h1>
            <button id="start-button" class="choice-btn">BEGIN</button>
            <button id="endings-button" class="choice-btn" onclick="toggleEndingsMenu()">ENDINGS</button>
        </div>

        <div id="game-screen" class="screen">
            <h1 id="game-title">The Silent Corridor</h1>
            <div id="story-text">
                </div>
            <div id="choices">
                </div>
        </div>
    </div>
    <script>
        // --- Game Logic and State Management ---
        const storyTextEl = document.getElementById('story-text');
        const choicesEl = document.getElementById('choices');
        const gameContainerEl = document.getElementById('gameContainer');

        const startScreenEl = document.getElementById('start-screen');
        const gameScreenEl = document.getElementById('game-screen');
        const startButtonEl = document.getElementById('start-button'); 

        const sidebarEl = document.getElementById('endings-sidebar');
        const listContentEl = document.getElementById('endings-list-content');
        
        // NEW: Get the ambiance audio elements
        const rainSfxEl = document.getElementById('rainSfx');
        const ambianceSfxEl = document.getElementById('ambianceSfx');


// Initialize the game state when the page loads
document.addEventListener('DOMContentLoaded', () => {
    // Check if any ending is unlocked to ensure the list is rendered on first view
    renderEndingsList(); 
    if (document.getElementById('start-screen').classList.contains('active')) {
        document.body.classList.remove('game-over');
    }
});

        let TOTAL_ENDINGS = 0; 
        const STORAGE_KEY = 'silentCorridorEndings';
        let gameState = {};
        let glitchTimer = null; 

        // CRITICAL CHANGE: Making storyNodes global so the console can read it
window.storyNodes = {
    start: {
        text: "You wake up in a cold sweat. The digital clock on your nightstand flickers '3:07 AM'. A strange, crushing silence hangs in the air, a silence deeper than the usual quiet of the night. It feels like the sound has been pulled out of the world, leaving a vibrating vacuum in its place. You feel an intense, primal need to move, to check the unsettling quiet and confirm your sanity.",
        choices: [
            { text: "Hide under the covers.", nextNode: "go_back_to_bed" },
            { text: "Venture into the corridor.", nextNode: "corridor_start" }, 
            { text: "Go to the study to look for your phone.", nextNode: "investigate_study_1" }, 
            { text: "Try the window ledge to escape the room.", nextNode: "bedroom_window_ledge_1" } // NEW Choice
        ]
    },
    
    // --- Bedroom Path ---
    go_back_to_bed: {
        text: "You burrow under the covers, trying to convince yourself it was just a dream. The blanket provides no comfort; the silence persists, chilling you more than the cold floor. You pull the blanket over your head, cutting off all light and sound. You can feel your heart pounding in your ears, the only sound left in the world.",
        choices: [
            { text: "Wait it out. Dawn has to come soon.", nextNode: "ending_safe" },
            { text: "The darkness under the blanket is too much. Peek out.", nextNode: "peek_out" },
            { text: "Accept the silence and wait for it.", nextNode: "go_back_to_bed_acceptance" } 
        ]
    },
    peek_out: {
        text: "You peek out from under the blanket. The room is the same, but the silence feels heavier, almost like pressure. Then you see it—a pair of pale, unblinking eyes reflecting the moonlight from the hallway, just outside your door frame. It is watching the crack.",
        choices: [
            { text: "Stare back and freeze.", nextNode: "death_staredown" },
            { text: "Scream and run for the bathroom.", nextNode: "corridor_start" }, 
            { text: "Slowly, quietly pull the door closed.", nextNode: "close_door" },
            { text: "Open the door slightly and offer it something.", nextNode: "sacrifice_door_2" } 
        ]
    },
    close_door: {
        text: "The hinges squeak, a sound like a gunshot in the crushing silence. The eyes blink once, quickly. You manage to latch the door before they fully open again. You stand frozen, leaning against the wood, heart in your throat. You know it is still there.",
        choices: [
            { text: "Wait at the door until morning.", nextNode: "ending_witness" }, 
            { text: "Try to open the window.", nextNode: "death_trapped" }
        ]
    },
    
    // --- Corridor Path ---
    corridor_start: {
        text: "You creep down the long, dark hall. The air is ice cold, and the temperature seems to drop with every step you take away from your room. Shadows seem to stretch and shift independently of the moonlight, lengthening and distorting familiar shapes. The corridor leads to the bathroom, the living room, the kitchen, the study, and a small back hall where the laundry room is located. You also spot your phone charger dangling from an outlet near a small table.",
        choices: [
            { text: "Check the bathroom.", nextNode: "investigate_bathroom_1" },
            { text: "Go to the living room.", nextNode: "investigate_living_room_1" }, 
            { text: "Go straight to the kitchen.", nextNode: "investigate_kitchen_1" },
            { text: "Go to the study.", nextNode: "investigate_study_1" },
            { text: "Check the laundry room down the back hall.", nextNode: "investigate_laundry_1" }, // NEW Choice
            { text: "Plug your phone into the corridor charger.", nextNode: "corridor_charger_2" } // NEW Choice
        ]
    },

    // --- Bathroom Path ---
    investigate_bathroom_1: {
        text: "The bathroom door is slightly ajar. A low, wet dripping sound breaks the silence—drip... drip... drip. It's the only sound you've heard that feels normal, yet it's unnervingly slow and rhythmic.",
        choices: [
            { text: "Push the door open slowly.", nextNode: "push_door" },
            { text: "Call out a name.", nextNode: "call_out" },
            { text: "Look under the sink, where the plumbing is.", nextNode: "bathroom_sink_2" }, // NEW Choice
            { text: "Run back to your room.", nextNode: "death_tripped" }
        ]
    },
    call_out: {
        text: "You whisper, 'Hello? Is someone there?' The dripping stops abruptly. You wait. A faint, low scratching sound comes from behind the door, rhythmic and deliberate, like someone dragging a broken fingernail across cold tile.",
        choices: [
            { text: "Open the door now!", nextNode: "push_door" },
            { text: "Listen closer to the scratching.", nextNode: "death_listened" }
        ]
    },
    push_door: {
        text: "You push the door open fully. There is nothing in the room but an old, dark bath towel hanging on the hook. The dripping was from the faucet. Relief washes over you, but the sense of dread doesn't completely leave. On the counter, you see a small, half-empty bottle of sleeping pills.",
        choices: [
            { text: "Take the sleeping pills and end the stress.", nextNode: "bathroom_medicine_2" },
            { text: "Climb out the window onto the narrow roof.", nextNode: "bathroom_window_2" },
            { text: "Look under the sink.", nextNode: "bathroom_sink_2" },
            { text: "Go to the kitchen.", nextNode: "investigate_kitchen_1" }
        ]
    },
    
    // --- Kitchen Path ---
    investigate_kitchen_1: {
        text: "The kitchen is darker than the hall. The large window shows the yard outside. You notice a faint, sulfurous smell, like burnt matches. A cupboard door is slightly ajar, rattling gently in a nonexistent breeze. You see an old, dusty shortwave radio sitting on a high shelf.",
        choices: [
            { text: "Investigate the rattling cupboard.", nextNode: "kitchen_cupboard_2" },
            { text: "Try to use the shortwave radio to find a voice.", nextNode: "kitchen_radio_2" }, 
            { text: "Check the back door for a lock.", nextNode: "kitchen_back_door_2" },
            { text: "Open the freezer, maybe find something to use as a weapon.", nextNode: "kitchen_freezer_3" }, // NEW Choice
            { text: "Try to light the gas stove to create light and sound.", nextNode: "kitchen_stove_3" } // NEW Choice
        ]
    },
    kitchen_cupboard_2: {
        text: "You slowly open the cupboard. It's filled with mundane things: plates, mugs, glasses. As you reach inside, a single glass falls off the shelf and shatters on the floor. The sound is deafening. The rattling stops, replaced by an even deeper silence.",
        choices: [
            // ... (The rest of the story nodes remain the same)
        ]
    },

    // ... (The rest of storyNodes remains the same) ...

    // --- ENDINGS (IDs 1-30) --- // Original Endings 1-10
    ending_safe: { 
        text: "You manage to fall asleep just before dawn. You survive the night, but the silence haunts your dreams for weeks to come. Was any of it real? You can never be sure.", 
        endingTitle: "ENDING 1/30: Survival", 
        choices: [{ text: "Return to Title Screen", nextNode: "title_screen" }], 
        isEnding: true, 
        endingId: 1 
    }, 
    // ... (rest of endings remain the same) ...
    
    title_screen: { 
        text: "Returning to the main menu...", 
        choices: [], 
        isTitle: true 
    } 
}; // --- Game...

        // ADDED: The startGame function is defined here to include the audio playing logic.
        function startGame() {
            // 1. Play both ambiance tracks when the user interacts with the 'BEGIN' button.
            
            // Set the volume for the ambiance track to 25% (0.25)
            ambianceSfxEl.volume = 0.25; 

            rainSfxEl.play().catch(e => console.log("Rain audio play blocked by browser:", e));
            ambianceSfxEl.play().catch(e => console.log("Ambiance audio play blocked by browser:", e));
            
            // 2. Original game start logic
            showScreen('game');
            showStoryNode('start');
        }

        // --- Other Utility Functions (unchanged) ---

        // Helper function to show a specific screen
        function showScreen(screenId) {
            startScreenEl.classList.remove('active');
            gameScreenEl.classList.remove('active');
            
            if (screenId === 'start') {
                startScreenEl.classList.add('active');
            } else if (screenId === 'game') {
                gameScreenEl.classList.add('active');
            }
        }
        
        // Helper function to stop the screen glitch effect
        function stopGlitch() {
            gameContainerEl.classList.remove('glitch-active');
            if (glitchTimer) {
                clearTimeout(glitchTimer);
                glitchTimer = null;
            }
        }

        // Helper function to set a random glitch effect timer
        function setRandomGlitchTimer() {
            stopGlitch(); 
            // Glitch occurs every 5 to 15 seconds
            const randomTime = Math.random() * 10000 + 5000; 
            glitchTimer = setTimeout(() => {
                // Apply glitch effect for a very short duration (e.g., 100ms)
                gameContainerEl.classList.add('glitch-active');
                setTimeout(() => {
                    gameContainerEl.classList.remove('glitch-active');
                }, 100); 
                // Then restart the timer for the next random interval
                setRandomGlitchTimer();
            }, randomTime);
        }

        // Helper function to manage the endings sidebar
        function toggleEndingsMenu() {
            // Re-render the list every time it opens to show the latest status
            renderEndingsList();
            
            // Toggle the sidebar's open class
            sidebarEl.classList.toggle('open');
            // Toggle the body class to push the main content
            document.body.classList.toggle('sidebar-open');
        }

        // Function to load/initialize endings from local storage
        function getEndingsStatus() {
            let status = {};
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    status = JSON.parse(stored);
                }
            } catch (e) {
                console.error("Could not load endings from storage:", e);
            }
            return status;
        }

        // Function to unlock and save an ending
        function unlockEnding(endingId) {
            const status = getEndingsStatus();
            status[endingId] = true;
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(status));
            } catch (e) {
                console.error("Could not save endings to storage:", e);
            }
        }

        // Function to calculate total number of endings
        function calculateTotalEndings() {
            let count = 0;
            for (const key in storyNodes) {
                if (storyNodes[key].isEnding) {
                    count++;
                }
            }
            TOTAL_ENDINGS = count;
        }

        // Function to render the endings list in the sidebar
        function renderEndingsList() {
            const status = getEndingsStatus();
            listContentEl.innerHTML = ''; // Clear existing list
            
            let unlockedCount = 0;
            const endingNodes = Object.values(storyNodes).filter(node => node.isEnding);

            endingNodes.forEach(node => {
                const isUnlocked = status[node.endingId] === true;
                if (isUnlocked) {
                    unlockedCount++;
                }

                const endingDiv = document.createElement('div');
                endingDiv.classList.add('ending-item');
                if (isUnlocked) {
                    endingDiv.classList.add('unlocked');
                }

                const nameSpan = document.createElement('span');
                nameSpan.classList.add('ending-name');
                nameSpan.textContent = isUnlocked ? node.endingTitle : `???`;

                const statusSpan = document.createElement('span');
                statusSpan.classList.add('status');
                statusSpan.textContent = isUnlocked ? '✓' : '✖';

                endingDiv.appendChild(nameSpan);
                endingDiv.appendChild(statusSpan);
                listContentEl.appendChild(endingDiv);
            });
            
            // Add a summary at the top
            const summary = document.createElement('div');
            summary.innerHTML = `<p style="text-align:center; color: #fff; border-bottom: 1px dashed #444; padding-bottom: 10px; margin-bottom: 10px;">
                <strong>${unlockedCount} / ${TOTAL_ENDINGS}</strong> Endings Found
            </p>`;
            listContentEl.prepend(summary);

            // If no endings are defined, show a message
            if (TOTAL_ENDINGS === 0) {
                listContentEl.innerHTML = `<p style="text-align:center; color: #aaa;">No endings defined yet.</p>`;
            }
        }

        // Main function to display a story node
        function showStoryNode(nodeName) {
            const node = storyNodes[nodeName];
            if (!node) {
                console.error(`Story node not found: ${nodeName}`);
                return;
            }

            // Handle Endings/Death
            if (node.isEnding && node.endingId) {
                unlockEnding(node.endingId);
            }
            
            // Handle Title Screen logic
            if (node.isTitle) {
                // Give a moment for the 'Return to Title Screen' text to show, then transition
                setTimeout(() => {
                    showScreen('start');
                    gameContainerEl.classList.remove('game-over');
                }, 100); 
                return; 
            }

            // Update story text
            let htmlContent = `<p class="description">${node.text}</p>`;
            if (node.isDeath) {
                htmlContent = `<h2>DEATH</h2>` + htmlContent;
            } else if (node.isEnding) {
                htmlContent = `<h2>${node.endingTitle}</h2>` + htmlContent;
            }
            storyTextEl.innerHTML = htmlContent;

            // Clear old choices
            while (choicesEl.firstChild) {
                choicesEl.removeChild(choicesEl.firstChild);
            }

            // Add new choices
            const currentChoices = node.choices || [];
            currentChoices.forEach(choice => {
                const button = document.createElement('button');
                button.innerText = choice.text;
                button.classList.add('choice-btn');
                button.addEventListener('click', () => showStoryNode(choice.nextNode));
                choicesEl.appendChild(button);
            });

            // Handle Glitch/Game Over state
            if (node.isDeath || node.isEnding) {
                gameContainerEl.classList.add('game-over');
                stopGlitch(); 
            } else {
                gameContainerEl.classList.remove('game-over');
                setRandomGlitchTimer(); 
            }
        }
        
        // --- Flashlight Effect ---
        function handleMouseMove(e) {
            // Update CSS variables for the flashlight to follow the cursor
            document.body.style.setProperty('--x', `${e.clientX}px`);
            document.body.style.setProperty('--y', `${e.clientY}px`);
        }
        document.addEventListener('mousemove', handleMouseMove);


        // --- Event Listeners and Initialization ---

        startButtonEl.addEventListener('click', startGame);

        // Calculate total on load and show the start screen
        calculateTotalEndings();
        showScreen('start');
    </script>
</body>
</html>